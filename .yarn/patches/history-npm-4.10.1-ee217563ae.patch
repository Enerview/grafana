diff --git a/cjs/history.js b/cjs/history.js
index fcd8ebab613c6d87b9ac824feb30ab1080cf0ef2..6542896891c8c847cbaddd79b364c14056df33ea 100644
--- a/cjs/history.js
+++ b/cjs/history.js
@@ -1,59 +1,66 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, "__esModule", { value: true });
 
-function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
+function _interopDefault(ex) {
+  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
+}
 
-var resolvePathname = _interopDefault(require('resolve-pathname'));
-var valueEqual = _interopDefault(require('value-equal'));
-var warning = _interopDefault(require('tiny-warning'));
-var invariant = _interopDefault(require('tiny-invariant'));
+var resolvePathname = _interopDefault(require("resolve-pathname"));
+var valueEqual = _interopDefault(require("value-equal"));
+var warning = _interopDefault(require("tiny-warning"));
+var invariant = _interopDefault(require("tiny-invariant"));
 
 function _extends() {
-  _extends = Object.assign || function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
+  _extends =
+    Object.assign ||
+    function (target) {
+      for (var i = 1; i < arguments.length; i++) {
+        var source = arguments[i];
+
+        for (var key in source) {
+          if (Object.prototype.hasOwnProperty.call(source, key)) {
+            target[key] = source[key];
+          }
         }
       }
-    }
 
-    return target;
-  };
+      return target;
+    };
 
   return _extends.apply(this, arguments);
 }
 
 function addLeadingSlash(path) {
-  return path.charAt(0) === '/' ? path : '/' + path;
+  return path.charAt(0) === "/" ? path : "/" + path;
 }
 function stripLeadingSlash(path) {
-  return path.charAt(0) === '/' ? path.substr(1) : path;
+  return path.charAt(0) === "/" ? path.substr(1) : path;
 }
 function hasBasename(path, prefix) {
-  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
+  return (
+    path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 &&
+    "/?#".indexOf(path.charAt(prefix.length)) !== -1
+  );
 }
 function stripBasename(path, prefix) {
   return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
 }
 function stripTrailingSlash(path) {
-  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
+  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
 }
 function parsePath(path) {
-  var pathname = path || '/';
-  var search = '';
-  var hash = '';
-  var hashIndex = pathname.indexOf('#');
+  var pathname = path || "/";
+  var search = "";
+  var hash = "";
+  var hashIndex = pathname.indexOf("#");
 
   if (hashIndex !== -1) {
     hash = pathname.substr(hashIndex);
     pathname = pathname.substr(0, hashIndex);
   }
 
-  var searchIndex = pathname.indexOf('?');
+  var searchIndex = pathname.indexOf("?");
 
   if (searchIndex !== -1) {
     search = pathname.substr(searchIndex);
@@ -62,55 +69,48 @@ function parsePath(path) {
 
   return {
     pathname: pathname,
-    search: search === '?' ? '' : search,
-    hash: hash === '#' ? '' : hash
+    search: search === "?" ? "" : search,
+    hash: hash === "#" ? "" : hash,
   };
 }
 function createPath(location) {
   var pathname = location.pathname,
-      search = location.search,
-      hash = location.hash;
-  var path = pathname || '/';
-  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
-  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
+    search = location.search,
+    hash = location.hash;
+  var path = pathname || "/";
+  if (search && search !== "?")
+    path += search.charAt(0) === "?" ? search : "?" + search;
+  if (hash && hash !== "#") path += hash.charAt(0) === "#" ? hash : "#" + hash;
   return path;
 }
 
 function createLocation(path, state, key, currentLocation) {
   var location;
 
-  if (typeof path === 'string') {
+  if (typeof path === "string") {
     // Two-arg form: push(path, state)
     location = parsePath(path);
     location.state = state;
   } else {
     // One-arg form: push(location)
     location = _extends({}, path);
-    if (location.pathname === undefined) location.pathname = '';
+    if (location.pathname === undefined) location.pathname = "";
 
     if (location.search) {
-      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
+      if (location.search.charAt(0) !== "?")
+        location.search = "?" + location.search;
     } else {
-      location.search = '';
+      location.search = "";
     }
 
     if (location.hash) {
-      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
+      if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
     } else {
-      location.hash = '';
+      location.hash = "";
     }
 
-    if (state !== undefined && location.state === undefined) location.state = state;
-  }
-
-  try {
-    location.pathname = decodeURI(location.pathname);
-  } catch (e) {
-    if (e instanceof URIError) {
-      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
-    } else {
-      throw e;
-    }
+    if (state !== undefined && location.state === undefined)
+      location.state = state;
   }
 
   if (key) location.key = key;
@@ -119,45 +119,63 @@ function createLocation(path, state, key, currentLocation) {
     // Resolve incomplete/relative pathname relative to current location.
     if (!location.pathname) {
       location.pathname = currentLocation.pathname;
-    } else if (location.pathname.charAt(0) !== '/') {
-      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
+    } else if (location.pathname.charAt(0) !== "/") {
+      location.pathname = resolvePathname(
+        location.pathname,
+        currentLocation.pathname
+      );
     }
   } else {
     // When there is no prior location and pathname is empty, set it to /
     if (!location.pathname) {
-      location.pathname = '/';
+      location.pathname = "/";
     }
   }
 
   return location;
 }
 function locationsAreEqual(a, b) {
-  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
+  return (
+    a.pathname === b.pathname &&
+    a.search === b.search &&
+    a.hash === b.hash &&
+    a.key === b.key &&
+    valueEqual(a.state, b.state)
+  );
 }
 
 function createTransitionManager() {
   var prompt = null;
 
   function setPrompt(nextPrompt) {
-    warning(prompt == null, 'A history supports only one prompt at a time');
+    warning(prompt == null, "A history supports only one prompt at a time");
     prompt = nextPrompt;
     return function () {
       if (prompt === nextPrompt) prompt = null;
     };
   }
 
-  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
+  function confirmTransitionTo(
+    location,
+    action,
+    getUserConfirmation,
+    callback
+  ) {
     // TODO: If another transition starts while we're still confirming
     // the previous one, we may end up in a weird state. Figure out the
     // best way to handle this.
     if (prompt != null) {
-      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;
+      var result =
+        typeof prompt === "function" ? prompt(location, action) : prompt;
 
-      if (typeof result === 'string') {
-        if (typeof getUserConfirmation === 'function') {
+      if (typeof result === "string") {
+        if (typeof getUserConfirmation === "function") {
           getUserConfirmation(result, callback);
         } else {
-          warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
+          warning(
+            false,
+            "A history needs a getUserConfirmation function in order to use a prompt message"
+          );
           callback(true);
         }
       } else {
@@ -188,7 +206,11 @@ function createTransitionManager() {
   }
 
   function notifyListeners() {
-    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+    for (
+      var _len = arguments.length, args = new Array(_len), _key = 0;
+      _key < _len;
+      _key++
+    ) {
       args[_key] = arguments[_key];
     }
 
@@ -201,11 +223,15 @@ function createTransitionManager() {
     setPrompt: setPrompt,
     confirmTransitionTo: confirmTransitionTo,
     appendListener: appendListener,
-    notifyListeners: notifyListeners
+    notifyListeners: notifyListeners,
   };
 }
 
-var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
+var canUseDOM = !!(
+  typeof window !== "undefined" &&
+  window.document &&
+  window.document.createElement
+);
 function getConfirmation(message, callback) {
   callback(window.confirm(message)); // eslint-disable-line no-alert
 }
@@ -219,8 +245,14 @@ function getConfirmation(message, callback) {
 
 function supportsHistory() {
   var ua = window.navigator.userAgent;
-  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
-  return window.history && 'pushState' in window.history;
+  if (
+    (ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) &&
+    ua.indexOf("Mobile Safari") !== -1 &&
+    ua.indexOf("Chrome") === -1 &&
+    ua.indexOf("Windows Phone") === -1
+  )
+    return false;
+  return window.history && "pushState" in window.history;
 }
 /**
  * Returns true if browser fires popstate on hash change.
@@ -228,14 +260,14 @@ function supportsHistory() {
  */
 
 function supportsPopStateOnHashChange() {
-  return window.navigator.userAgent.indexOf('Trident') === -1;
+  return window.navigator.userAgent.indexOf("Trident") === -1;
 }
 /**
  * Returns false if using go(n) with hash history causes a full page reload.
  */
 
 function supportsGoWithoutReloadUsingHash() {
-  return window.navigator.userAgent.indexOf('Firefox') === -1;
+  return window.navigator.userAgent.indexOf("Firefox") === -1;
 }
 /**
  * Returns true if a given popstate event is an extraneous WebKit event.
@@ -244,11 +276,13 @@ function supportsGoWithoutReloadUsingHash() {
  */
 
 function isExtraneousPopstateEvent(event) {
-  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
+  return (
+    event.state === undefined && navigator.userAgent.indexOf("CriOS") === -1
+  );
 }
 
-var PopStateEvent = 'popstate';
-var HashChangeEvent = 'hashchange';
+var PopStateEvent = "popstate";
+var HashChangeEvent = "hashchange";
 
 function getHistoryState() {
   try {
@@ -264,36 +298,48 @@ function getHistoryState() {
  * pushState, replaceState, and the popstate event.
  */
 
-
 function createBrowserHistory(props) {
   if (props === void 0) {
     props = {};
   }
 
-  !canUseDOM ? invariant(false, 'Browser history needs a DOM') : void 0;
+  !canUseDOM ? invariant(false, "Browser history needs a DOM") : void 0;
   var globalHistory = window.history;
   var canUseHistory = supportsHistory();
   var needsHashChangeListener = !supportsPopStateOnHashChange();
   var _props = props,
-      _props$forceRefresh = _props.forceRefresh,
-      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
-      _props$getUserConfirm = _props.getUserConfirmation,
-      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-      _props$keyLength = _props.keyLength,
-      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
-  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+    _props$forceRefresh = _props.forceRefresh,
+    forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
+    _props$getUserConfirm = _props.getUserConfirmation,
+    getUserConfirmation =
+      _props$getUserConfirm === void 0
+        ? getConfirmation
+        : _props$getUserConfirm,
+    _props$keyLength = _props.keyLength,
+    keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+  var basename = props.basename
+    ? stripTrailingSlash(addLeadingSlash(props.basename))
+    : "";
 
   function getDOMLocation(historyState) {
     var _ref = historyState || {},
-        key = _ref.key,
-        state = _ref.state;
+      key = _ref.key,
+      state = _ref.state;
 
     var _window$location = window.location,
-        pathname = _window$location.pathname,
-        search = _window$location.search,
-        hash = _window$location.hash;
+      pathname = _window$location.pathname,
+      search = _window$location.search,
+      hash = _window$location.hash;
     var path = pathname + search + hash;
-    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
+    warning(
+      !basename || hasBasename(path, basename),
+      "You are attempting to use a basename on a page whose URL path does not begin " +
+        'with the basename. Expected path "' +
+        path +
+        '" to begin with "' +
+        basename +
+        '".'
+    );
     if (basename) path = stripBasename(path, basename);
     return createLocation(path, state, key);
   }
@@ -328,17 +374,22 @@ function createBrowserHistory(props) {
       forceNextPop = false;
       setState();
     } else {
-      var action = 'POP';
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (ok) {
-          setState({
-            action: action,
-            location: location
-          });
-        } else {
-          revertPop(location);
+      var action = "POP";
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (ok) {
+            setState({
+              action: action,
+              location: location,
+            });
+          } else {
+            revertPop(location);
+          }
         }
-      });
+      );
     }
   }
 
@@ -367,71 +418,111 @@ function createBrowserHistory(props) {
   }
 
   function push(path, state) {
-    warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-    var action = 'PUSH';
+    warning(
+      !(
+        typeof path === "object" &&
+        path.state !== undefined &&
+        state !== undefined
+      ),
+      "You should avoid providing a 2nd state argument to push when the 1st " +
+        "argument is a location-like object that already has state; it is ignored"
+    );
+    var action = "PUSH";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var href = createHref(location);
-      var key = location.key,
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var href = createHref(location);
+        var key = location.key,
           state = location.state;
 
-      if (canUseHistory) {
-        globalHistory.pushState({
-          key: key,
-          state: state
-        }, null, href);
-
-        if (forceRefresh) {
-          window.location.href = href;
+        if (canUseHistory) {
+          globalHistory.pushState(
+            {
+              key: key,
+              state: state,
+            },
+            null,
+            href
+          );
+
+          if (forceRefresh) {
+            window.location.href = href;
+          } else {
+            var prevIndex = allKeys.indexOf(history.location.key);
+            var nextKeys = allKeys.slice(0, prevIndex + 1);
+            nextKeys.push(location.key);
+            allKeys = nextKeys;
+            setState({
+              action: action,
+              location: location,
+            });
+          }
         } else {
-          var prevIndex = allKeys.indexOf(history.location.key);
-          var nextKeys = allKeys.slice(0, prevIndex + 1);
-          nextKeys.push(location.key);
-          allKeys = nextKeys;
-          setState({
-            action: action,
-            location: location
-          });
+          warning(
+            state === undefined,
+            "Browser history cannot push state in browsers that do not support HTML5 history"
+          );
+          window.location.href = href;
         }
-      } else {
-        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');
-        window.location.href = href;
       }
-    });
+    );
   }
 
   function replace(path, state) {
-    warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-    var action = 'REPLACE';
+    warning(
+      !(
+        typeof path === "object" &&
+        path.state !== undefined &&
+        state !== undefined
+      ),
+      "You should avoid providing a 2nd state argument to replace when the 1st " +
+        "argument is a location-like object that already has state; it is ignored"
+    );
+    var action = "REPLACE";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var href = createHref(location);
-      var key = location.key,
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var href = createHref(location);
+        var key = location.key,
           state = location.state;
 
-      if (canUseHistory) {
-        globalHistory.replaceState({
-          key: key,
-          state: state
-        }, null, href);
-
-        if (forceRefresh) {
-          window.location.replace(href);
+        if (canUseHistory) {
+          globalHistory.replaceState(
+            {
+              key: key,
+              state: state,
+            },
+            null,
+            href
+          );
+
+          if (forceRefresh) {
+            window.location.replace(href);
+          } else {
+            var prevIndex = allKeys.indexOf(history.location.key);
+            if (prevIndex !== -1) allKeys[prevIndex] = location.key;
+            setState({
+              action: action,
+              location: location,
+            });
+          }
         } else {
-          var prevIndex = allKeys.indexOf(history.location.key);
-          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
-          setState({
-            action: action,
-            location: location
-          });
+          warning(
+            state === undefined,
+            "Browser history cannot replace state in browsers that do not support HTML5 history"
+          );
+          window.location.replace(href);
         }
-      } else {
-        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');
-        window.location.replace(href);
       }
-    });
+    );
   }
 
   function go(n) {
@@ -453,10 +544,12 @@ function createBrowserHistory(props) {
 
     if (listenerCount === 1 && delta === 1) {
       window.addEventListener(PopStateEvent, handlePopState);
-      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
+      if (needsHashChangeListener)
+        window.addEventListener(HashChangeEvent, handleHashChange);
     } else if (listenerCount === 0) {
       window.removeEventListener(PopStateEvent, handlePopState);
-      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
+      if (needsHashChangeListener)
+        window.removeEventListener(HashChangeEvent, handleHashChange);
     }
   }
 
@@ -495,7 +588,7 @@ function createBrowserHistory(props) {
 
   var history = {
     length: globalHistory.length,
-    action: 'POP',
+    action: "POP",
     location: initialLocation,
     createHref: createHref,
     push: push,
@@ -504,33 +597,33 @@ function createBrowserHistory(props) {
     goBack: goBack,
     goForward: goForward,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
 
-var HashChangeEvent$1 = 'hashchange';
+var HashChangeEvent$1 = "hashchange";
 var HashPathCoders = {
   hashbang: {
     encodePath: function encodePath(path) {
-      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
+      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
     },
     decodePath: function decodePath(path) {
-      return path.charAt(0) === '!' ? path.substr(1) : path;
-    }
+      return path.charAt(0) === "!" ? path.substr(1) : path;
+    },
   },
   noslash: {
     encodePath: stripLeadingSlash,
-    decodePath: addLeadingSlash
+    decodePath: addLeadingSlash,
   },
   slash: {
     encodePath: addLeadingSlash,
-    decodePath: addLeadingSlash
-  }
+    decodePath: addLeadingSlash,
+  },
 };
 
 function stripHash(url) {
-  var hashIndex = url.indexOf('#');
+  var hashIndex = url.indexOf("#");
   return hashIndex === -1 ? url : url.slice(0, hashIndex);
 }
 
@@ -538,8 +631,8 @@ function getHashPath() {
   // We can't use window.location.hash here because it's not
   // consistent across browsers - Firefox will pre-decode it!
   var href = window.location.href;
-  var hashIndex = href.indexOf('#');
-  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
+  var hashIndex = href.indexOf("#");
+  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
 }
 
 function pushHashPath(path) {
@@ -547,7 +640,7 @@ function pushHashPath(path) {
 }
 
 function replaceHashPath(path) {
-  window.location.replace(stripHash(window.location.href) + '#' + path);
+  window.location.replace(stripHash(window.location.href) + "#" + path);
 }
 
 function createHashHistory(props) {
@@ -555,22 +648,35 @@ function createHashHistory(props) {
     props = {};
   }
 
-  !canUseDOM ? invariant(false, 'Hash history needs a DOM') : void 0;
+  !canUseDOM ? invariant(false, "Hash history needs a DOM") : void 0;
   var globalHistory = window.history;
   var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
   var _props = props,
-      _props$getUserConfirm = _props.getUserConfirmation,
-      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-      _props$hashType = _props.hashType,
-      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
-  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+    _props$getUserConfirm = _props.getUserConfirmation,
+    getUserConfirmation =
+      _props$getUserConfirm === void 0
+        ? getConfirmation
+        : _props$getUserConfirm,
+    _props$hashType = _props.hashType,
+    hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
+  var basename = props.basename
+    ? stripTrailingSlash(addLeadingSlash(props.basename))
+    : "";
   var _HashPathCoders$hashT = HashPathCoders[hashType],
-      encodePath = _HashPathCoders$hashT.encodePath,
-      decodePath = _HashPathCoders$hashT.decodePath;
+    encodePath = _HashPathCoders$hashT.encodePath,
+    decodePath = _HashPathCoders$hashT.decodePath;
 
   function getDOMLocation() {
     var path = decodePath(getHashPath());
-    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
+    warning(
+      !basename || hasBasename(path, basename),
+      "You are attempting to use a basename on a page whose URL path does not begin " +
+        'with the basename. Expected path "' +
+        path +
+        '" to begin with "' +
+        basename +
+        '".'
+    );
     if (basename) path = stripBasename(path, basename);
     return createLocation(path);
   }
@@ -588,7 +694,9 @@ function createHashHistory(props) {
   var ignorePath = null;
 
   function locationsAreEqual$$1(a, b) {
-    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
+    return (
+      a.pathname === b.pathname && a.search === b.search && a.hash === b.hash
+    );
   }
 
   function handleHashChange() {
@@ -615,17 +723,22 @@ function createHashHistory(props) {
       forceNextPop = false;
       setState();
     } else {
-      var action = 'POP';
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (ok) {
-          setState({
-            action: action,
-            location: location
-          });
-        } else {
-          revertPop(location);
+      var action = "POP";
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (ok) {
+            setState({
+              action: action,
+              location: location,
+            });
+          } else {
+            revertPop(location);
+          }
         }
-      });
+      );
     }
   }
 
@@ -646,7 +759,6 @@ function createHashHistory(props) {
     }
   } // Ensure the hash is encoded properly before doing anything else.
 
-
   var path = getHashPath();
   var encodedPath = encodePath(path);
   if (path !== encodedPath) replaceHashPath(encodedPath);
@@ -654,76 +766,98 @@ function createHashHistory(props) {
   var allPaths = [createPath(initialLocation)]; // Public interface
 
   function createHref(location) {
-    var baseTag = document.querySelector('base');
-    var href = '';
+    var baseTag = document.querySelector("base");
+    var href = "";
 
-    if (baseTag && baseTag.getAttribute('href')) {
+    if (baseTag && baseTag.getAttribute("href")) {
       href = stripHash(window.location.href);
     }
 
-    return href + '#' + encodePath(basename + createPath(location));
+    return href + "#" + encodePath(basename + createPath(location));
   }
 
   function push(path, state) {
-    warning(state === undefined, 'Hash history cannot push state; it is ignored');
-    var action = 'PUSH';
+    warning(
+      state === undefined,
+      "Hash history cannot push state; it is ignored"
+    );
+    var action = "PUSH";
     var location = createLocation(path, undefined, undefined, history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var path = createPath(location);
-      var encodedPath = encodePath(basename + path);
-      var hashChanged = getHashPath() !== encodedPath;
-
-      if (hashChanged) {
-        // We cannot tell if a hashchange was caused by a PUSH, so we'd
-        // rather setState here and ignore the hashchange. The caveat here
-        // is that other hash histories in the page will consider it a POP.
-        ignorePath = path;
-        pushHashPath(encodedPath);
-        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
-        var nextPaths = allPaths.slice(0, prevIndex + 1);
-        nextPaths.push(path);
-        allPaths = nextPaths;
-        setState({
-          action: action,
-          location: location
-        });
-      } else {
-        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
-        setState();
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var path = createPath(location);
+        var encodedPath = encodePath(basename + path);
+        var hashChanged = getHashPath() !== encodedPath;
+
+        if (hashChanged) {
+          // We cannot tell if a hashchange was caused by a PUSH, so we'd
+          // rather setState here and ignore the hashchange. The caveat here
+          // is that other hash histories in the page will consider it a POP.
+          ignorePath = path;
+          pushHashPath(encodedPath);
+          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
+          var nextPaths = allPaths.slice(0, prevIndex + 1);
+          nextPaths.push(path);
+          allPaths = nextPaths;
+          setState({
+            action: action,
+            location: location,
+          });
+        } else {
+          warning(
+            false,
+            "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"
+          );
+          setState();
+        }
       }
-    });
+    );
   }
 
   function replace(path, state) {
-    warning(state === undefined, 'Hash history cannot replace state; it is ignored');
-    var action = 'REPLACE';
+    warning(
+      state === undefined,
+      "Hash history cannot replace state; it is ignored"
+    );
+    var action = "REPLACE";
     var location = createLocation(path, undefined, undefined, history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var path = createPath(location);
-      var encodedPath = encodePath(basename + path);
-      var hashChanged = getHashPath() !== encodedPath;
-
-      if (hashChanged) {
-        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
-        // rather setState here and ignore the hashchange. The caveat here
-        // is that other hash histories in the page will consider it a POP.
-        ignorePath = path;
-        replaceHashPath(encodedPath);
-      }
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var path = createPath(location);
+        var encodedPath = encodePath(basename + path);
+        var hashChanged = getHashPath() !== encodedPath;
+
+        if (hashChanged) {
+          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
+          // rather setState here and ignore the hashchange. The caveat here
+          // is that other hash histories in the page will consider it a POP.
+          ignorePath = path;
+          replaceHashPath(encodedPath);
+        }
 
-      var prevIndex = allPaths.indexOf(createPath(history.location));
-      if (prevIndex !== -1) allPaths[prevIndex] = path;
-      setState({
-        action: action,
-        location: location
-      });
-    });
+        var prevIndex = allPaths.indexOf(createPath(history.location));
+        if (prevIndex !== -1) allPaths[prevIndex] = path;
+        setState({
+          action: action,
+          location: location,
+        });
+      }
+    );
   }
 
   function go(n) {
-    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
+    warning(
+      canGoWithoutReload,
+      "Hash history go(n) causes a full page reload in this browser"
+    );
     globalHistory.go(n);
   }
 
@@ -782,7 +916,7 @@ function createHashHistory(props) {
 
   var history = {
     length: globalHistory.length,
-    action: 'POP',
+    action: "POP",
     location: initialLocation,
     createHref: createHref,
     push: push,
@@ -791,7 +925,7 @@ function createHashHistory(props) {
     goBack: goBack,
     goForward: goForward,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
@@ -803,20 +937,20 @@ function clamp(n, lowerBound, upperBound) {
  * Creates a history object that stores locations in memory.
  */
 
-
 function createMemoryHistory(props) {
   if (props === void 0) {
     props = {};
   }
 
   var _props = props,
-      getUserConfirmation = _props.getUserConfirmation,
-      _props$initialEntries = _props.initialEntries,
-      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
-      _props$initialIndex = _props.initialIndex,
-      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
-      _props$keyLength = _props.keyLength,
-      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+    getUserConfirmation = _props.getUserConfirmation,
+    _props$initialEntries = _props.initialEntries,
+    initialEntries =
+      _props$initialEntries === void 0 ? ["/"] : _props$initialEntries,
+    _props$initialIndex = _props.initialIndex,
+    initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
+    _props$keyLength = _props.keyLength,
+    keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
   var transitionManager = createTransitionManager();
 
   function setState(nextState) {
@@ -832,67 +966,104 @@ function createMemoryHistory(props) {
 
   var index = clamp(initialIndex, 0, initialEntries.length - 1);
   var entries = initialEntries.map(function (entry) {
-    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
+    return typeof entry === "string"
+      ? createLocation(entry, undefined, createKey())
+      : createLocation(entry, undefined, entry.key || createKey());
   }); // Public interface
 
   var createHref = createPath;
 
   function push(path, state) {
-    warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-    var action = 'PUSH';
+    warning(
+      !(
+        typeof path === "object" &&
+        path.state !== undefined &&
+        state !== undefined
+      ),
+      "You should avoid providing a 2nd state argument to push when the 1st " +
+        "argument is a location-like object that already has state; it is ignored"
+    );
+    var action = "PUSH";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var prevIndex = history.index;
-      var nextIndex = prevIndex + 1;
-      var nextEntries = history.entries.slice(0);
-
-      if (nextEntries.length > nextIndex) {
-        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
-      } else {
-        nextEntries.push(location);
-      }
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var prevIndex = history.index;
+        var nextIndex = prevIndex + 1;
+        var nextEntries = history.entries.slice(0);
+
+        if (nextEntries.length > nextIndex) {
+          nextEntries.splice(
+            nextIndex,
+            nextEntries.length - nextIndex,
+            location
+          );
+        } else {
+          nextEntries.push(location);
+        }
 
-      setState({
-        action: action,
-        location: location,
-        index: nextIndex,
-        entries: nextEntries
-      });
-    });
+        setState({
+          action: action,
+          location: location,
+          index: nextIndex,
+          entries: nextEntries,
+        });
+      }
+    );
   }
 
   function replace(path, state) {
-    warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-    var action = 'REPLACE';
+    warning(
+      !(
+        typeof path === "object" &&
+        path.state !== undefined &&
+        state !== undefined
+      ),
+      "You should avoid providing a 2nd state argument to replace when the 1st " +
+        "argument is a location-like object that already has state; it is ignored"
+    );
+    var action = "REPLACE";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      history.entries[history.index] = location;
-      setState({
-        action: action,
-        location: location
-      });
-    });
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        history.entries[history.index] = location;
+        setState({
+          action: action,
+          location: location,
+        });
+      }
+    );
   }
 
   function go(n) {
     var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
-    var action = 'POP';
+    var action = "POP";
     var location = history.entries[nextIndex];
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (ok) {
-        setState({
-          action: action,
-          location: location,
-          index: nextIndex
-        });
-      } else {
-        // Mimic the behavior of DOM histories by
-        // causing a render after a cancelled POP.
-        setState();
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (ok) {
+          setState({
+            action: action,
+            location: location,
+            index: nextIndex,
+          });
+        } else {
+          // Mimic the behavior of DOM histories by
+          // causing a render after a cancelled POP.
+          setState();
+        }
       }
-    });
+    );
   }
 
   function goBack() {
@@ -922,7 +1093,7 @@ function createMemoryHistory(props) {
 
   var history = {
     length: entries.length,
-    action: 'POP',
+    action: "POP",
     location: entries[index],
     index: index,
     entries: entries,
@@ -934,7 +1105,7 @@ function createMemoryHistory(props) {
     goForward: goForward,
     canGo: canGo,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
diff --git a/esm/history.js b/esm/history.js
index df67820fe3eed558c44fca07a82b0cd409d46720..1ab7f9833977752e558dd17e28ae239b8510a524 100644
--- a/esm/history.js
+++ b/esm/history.js
@@ -1,36 +1,39 @@
-import _extends from '@babel/runtime/helpers/esm/extends';
-import resolvePathname from 'resolve-pathname';
-import valueEqual from 'value-equal';
-import warning from 'tiny-warning';
-import invariant from 'tiny-invariant';
+import _extends from "@babel/runtime/helpers/esm/extends";
+import resolvePathname from "resolve-pathname";
+import valueEqual from "value-equal";
+import warning from "tiny-warning";
+import invariant from "tiny-invariant";
 
 function addLeadingSlash(path) {
-  return path.charAt(0) === '/' ? path : '/' + path;
+  return path.charAt(0) === "/" ? path : "/" + path;
 }
 function stripLeadingSlash(path) {
-  return path.charAt(0) === '/' ? path.substr(1) : path;
+  return path.charAt(0) === "/" ? path.substr(1) : path;
 }
 function hasBasename(path, prefix) {
-  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
+  return (
+    path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 &&
+    "/?#".indexOf(path.charAt(prefix.length)) !== -1
+  );
 }
 function stripBasename(path, prefix) {
   return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
 }
 function stripTrailingSlash(path) {
-  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
+  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
 }
 function parsePath(path) {
-  var pathname = path || '/';
-  var search = '';
-  var hash = '';
-  var hashIndex = pathname.indexOf('#');
+  var pathname = path || "/";
+  var search = "";
+  var hash = "";
+  var hashIndex = pathname.indexOf("#");
 
   if (hashIndex !== -1) {
     hash = pathname.substr(hashIndex);
     pathname = pathname.substr(0, hashIndex);
   }
 
-  var searchIndex = pathname.indexOf('?');
+  var searchIndex = pathname.indexOf("?");
 
   if (searchIndex !== -1) {
     search = pathname.substr(searchIndex);
@@ -39,55 +42,48 @@ function parsePath(path) {
 
   return {
     pathname: pathname,
-    search: search === '?' ? '' : search,
-    hash: hash === '#' ? '' : hash
+    search: search === "?" ? "" : search,
+    hash: hash === "#" ? "" : hash,
   };
 }
 function createPath(location) {
   var pathname = location.pathname,
-      search = location.search,
-      hash = location.hash;
-  var path = pathname || '/';
-  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
-  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
+    search = location.search,
+    hash = location.hash;
+  var path = pathname || "/";
+  if (search && search !== "?")
+    path += search.charAt(0) === "?" ? search : "?" + search;
+  if (hash && hash !== "#") path += hash.charAt(0) === "#" ? hash : "#" + hash;
   return path;
 }
 
 function createLocation(path, state, key, currentLocation) {
   var location;
 
-  if (typeof path === 'string') {
+  if (typeof path === "string") {
     // Two-arg form: push(path, state)
     location = parsePath(path);
     location.state = state;
   } else {
     // One-arg form: push(location)
     location = _extends({}, path);
-    if (location.pathname === undefined) location.pathname = '';
+    if (location.pathname === undefined) location.pathname = "";
 
     if (location.search) {
-      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
+      if (location.search.charAt(0) !== "?")
+        location.search = "?" + location.search;
     } else {
-      location.search = '';
+      location.search = "";
     }
 
     if (location.hash) {
-      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
+      if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
     } else {
-      location.hash = '';
+      location.hash = "";
     }
 
-    if (state !== undefined && location.state === undefined) location.state = state;
-  }
-
-  try {
-    location.pathname = decodeURI(location.pathname);
-  } catch (e) {
-    if (e instanceof URIError) {
-      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
-    } else {
-      throw e;
-    }
+    if (state !== undefined && location.state === undefined)
+      location.state = state;
   }
 
   if (key) location.key = key;
@@ -96,45 +92,67 @@ function createLocation(path, state, key, currentLocation) {
     // Resolve incomplete/relative pathname relative to current location.
     if (!location.pathname) {
       location.pathname = currentLocation.pathname;
-    } else if (location.pathname.charAt(0) !== '/') {
-      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
+    } else if (location.pathname.charAt(0) !== "/") {
+      location.pathname = resolvePathname(
+        location.pathname,
+        currentLocation.pathname
+      );
     }
   } else {
     // When there is no prior location and pathname is empty, set it to /
     if (!location.pathname) {
-      location.pathname = '/';
+      location.pathname = "/";
     }
   }
 
   return location;
 }
 function locationsAreEqual(a, b) {
-  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
+  return (
+    a.pathname === b.pathname &&
+    a.search === b.search &&
+    a.hash === b.hash &&
+    a.key === b.key &&
+    valueEqual(a.state, b.state)
+  );
 }
 
 function createTransitionManager() {
   var prompt = null;
 
   function setPrompt(nextPrompt) {
-    process.env.NODE_ENV !== "production" ? warning(prompt == null, 'A history supports only one prompt at a time') : void 0;
+    process.env.NODE_ENV !== "production"
+      ? warning(prompt == null, "A history supports only one prompt at a time")
+      : void 0;
     prompt = nextPrompt;
     return function () {
       if (prompt === nextPrompt) prompt = null;
     };
   }
 
-  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
+  function confirmTransitionTo(
+    location,
+    action,
+    getUserConfirmation,
+    callback
+  ) {
     // TODO: If another transition starts while we're still confirming
     // the previous one, we may end up in a weird state. Figure out the
     // best way to handle this.
     if (prompt != null) {
-      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;
+      var result =
+        typeof prompt === "function" ? prompt(location, action) : prompt;
 
-      if (typeof result === 'string') {
-        if (typeof getUserConfirmation === 'function') {
+      if (typeof result === "string") {
+        if (typeof getUserConfirmation === "function") {
           getUserConfirmation(result, callback);
         } else {
-          process.env.NODE_ENV !== "production" ? warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;
+          process.env.NODE_ENV !== "production"
+            ? warning(
+                false,
+                "A history needs a getUserConfirmation function in order to use a prompt message"
+              )
+            : void 0;
           callback(true);
         }
       } else {
@@ -165,7 +183,11 @@ function createTransitionManager() {
   }
 
   function notifyListeners() {
-    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+    for (
+      var _len = arguments.length, args = new Array(_len), _key = 0;
+      _key < _len;
+      _key++
+    ) {
       args[_key] = arguments[_key];
     }
 
@@ -178,11 +200,15 @@ function createTransitionManager() {
     setPrompt: setPrompt,
     confirmTransitionTo: confirmTransitionTo,
     appendListener: appendListener,
-    notifyListeners: notifyListeners
+    notifyListeners: notifyListeners,
   };
 }
 
-var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
+var canUseDOM = !!(
+  typeof window !== "undefined" &&
+  window.document &&
+  window.document.createElement
+);
 function getConfirmation(message, callback) {
   callback(window.confirm(message)); // eslint-disable-line no-alert
 }
@@ -196,8 +222,14 @@ function getConfirmation(message, callback) {
 
 function supportsHistory() {
   var ua = window.navigator.userAgent;
-  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
-  return window.history && 'pushState' in window.history;
+  if (
+    (ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) &&
+    ua.indexOf("Mobile Safari") !== -1 &&
+    ua.indexOf("Chrome") === -1 &&
+    ua.indexOf("Windows Phone") === -1
+  )
+    return false;
+  return window.history && "pushState" in window.history;
 }
 /**
  * Returns true if browser fires popstate on hash change.
@@ -205,14 +237,14 @@ function supportsHistory() {
  */
 
 function supportsPopStateOnHashChange() {
-  return window.navigator.userAgent.indexOf('Trident') === -1;
+  return window.navigator.userAgent.indexOf("Trident") === -1;
 }
 /**
  * Returns false if using go(n) with hash history causes a full page reload.
  */
 
 function supportsGoWithoutReloadUsingHash() {
-  return window.navigator.userAgent.indexOf('Firefox') === -1;
+  return window.navigator.userAgent.indexOf("Firefox") === -1;
 }
 /**
  * Returns true if a given popstate event is an extraneous WebKit event.
@@ -221,11 +253,13 @@ function supportsGoWithoutReloadUsingHash() {
  */
 
 function isExtraneousPopstateEvent(event) {
-  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
+  return (
+    event.state === undefined && navigator.userAgent.indexOf("CriOS") === -1
+  );
 }
 
-var PopStateEvent = 'popstate';
-var HashChangeEvent = 'hashchange';
+var PopStateEvent = "popstate";
+var HashChangeEvent = "hashchange";
 
 function getHistoryState() {
   try {
@@ -241,36 +275,54 @@ function getHistoryState() {
  * pushState, replaceState, and the popstate event.
  */
 
-
 function createBrowserHistory(props) {
   if (props === void 0) {
     props = {};
   }
 
-  !canUseDOM ? process.env.NODE_ENV !== "production" ? invariant(false, 'Browser history needs a DOM') : invariant(false) : void 0;
+  !canUseDOM
+    ? process.env.NODE_ENV !== "production"
+      ? invariant(false, "Browser history needs a DOM")
+      : invariant(false)
+    : void 0;
   var globalHistory = window.history;
   var canUseHistory = supportsHistory();
   var needsHashChangeListener = !supportsPopStateOnHashChange();
   var _props = props,
-      _props$forceRefresh = _props.forceRefresh,
-      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
-      _props$getUserConfirm = _props.getUserConfirmation,
-      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-      _props$keyLength = _props.keyLength,
-      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
-  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+    _props$forceRefresh = _props.forceRefresh,
+    forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
+    _props$getUserConfirm = _props.getUserConfirmation,
+    getUserConfirmation =
+      _props$getUserConfirm === void 0
+        ? getConfirmation
+        : _props$getUserConfirm,
+    _props$keyLength = _props.keyLength,
+    keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+  var basename = props.basename
+    ? stripTrailingSlash(addLeadingSlash(props.basename))
+    : "";
 
   function getDOMLocation(historyState) {
     var _ref = historyState || {},
-        key = _ref.key,
-        state = _ref.state;
+      key = _ref.key,
+      state = _ref.state;
 
     var _window$location = window.location,
-        pathname = _window$location.pathname,
-        search = _window$location.search,
-        hash = _window$location.hash;
+      pathname = _window$location.pathname,
+      search = _window$location.search,
+      hash = _window$location.hash;
     var path = pathname + search + hash;
-    process.env.NODE_ENV !== "production" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !basename || hasBasename(path, basename),
+          "You are attempting to use a basename on a page whose URL path does not begin " +
+            'with the basename. Expected path "' +
+            path +
+            '" to begin with "' +
+            basename +
+            '".'
+        )
+      : void 0;
     if (basename) path = stripBasename(path, basename);
     return createLocation(path, state, key);
   }
@@ -305,17 +357,22 @@ function createBrowserHistory(props) {
       forceNextPop = false;
       setState();
     } else {
-      var action = 'POP';
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (ok) {
-          setState({
-            action: action,
-            location: location
-          });
-        } else {
-          revertPop(location);
+      var action = "POP";
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (ok) {
+            setState({
+              action: action,
+              location: location,
+            });
+          } else {
+            revertPop(location);
+          }
         }
-      });
+      );
     }
   }
 
@@ -344,71 +401,119 @@ function createBrowserHistory(props) {
   }
 
   function push(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
-    var action = 'PUSH';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !(
+            typeof path === "object" &&
+            path.state !== undefined &&
+            state !== undefined
+          ),
+          "You should avoid providing a 2nd state argument to push when the 1st " +
+            "argument is a location-like object that already has state; it is ignored"
+        )
+      : void 0;
+    var action = "PUSH";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var href = createHref(location);
-      var key = location.key,
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var href = createHref(location);
+        var key = location.key,
           state = location.state;
 
-      if (canUseHistory) {
-        globalHistory.pushState({
-          key: key,
-          state: state
-        }, null, href);
-
-        if (forceRefresh) {
-          window.location.href = href;
+        if (canUseHistory) {
+          globalHistory.pushState(
+            {
+              key: key,
+              state: state,
+            },
+            null,
+            href
+          );
+
+          if (forceRefresh) {
+            window.location.href = href;
+          } else {
+            var prevIndex = allKeys.indexOf(history.location.key);
+            var nextKeys = allKeys.slice(0, prevIndex + 1);
+            nextKeys.push(location.key);
+            allKeys = nextKeys;
+            setState({
+              action: action,
+              location: location,
+            });
+          }
         } else {
-          var prevIndex = allKeys.indexOf(history.location.key);
-          var nextKeys = allKeys.slice(0, prevIndex + 1);
-          nextKeys.push(location.key);
-          allKeys = nextKeys;
-          setState({
-            action: action,
-            location: location
-          });
+          process.env.NODE_ENV !== "production"
+            ? warning(
+                state === undefined,
+                "Browser history cannot push state in browsers that do not support HTML5 history"
+              )
+            : void 0;
+          window.location.href = href;
         }
-      } else {
-        process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : void 0;
-        window.location.href = href;
       }
-    });
+    );
   }
 
   function replace(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
-    var action = 'REPLACE';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !(
+            typeof path === "object" &&
+            path.state !== undefined &&
+            state !== undefined
+          ),
+          "You should avoid providing a 2nd state argument to replace when the 1st " +
+            "argument is a location-like object that already has state; it is ignored"
+        )
+      : void 0;
+    var action = "REPLACE";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var href = createHref(location);
-      var key = location.key,
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var href = createHref(location);
+        var key = location.key,
           state = location.state;
 
-      if (canUseHistory) {
-        globalHistory.replaceState({
-          key: key,
-          state: state
-        }, null, href);
-
-        if (forceRefresh) {
-          window.location.replace(href);
+        if (canUseHistory) {
+          globalHistory.replaceState(
+            {
+              key: key,
+              state: state,
+            },
+            null,
+            href
+          );
+
+          if (forceRefresh) {
+            window.location.replace(href);
+          } else {
+            var prevIndex = allKeys.indexOf(history.location.key);
+            if (prevIndex !== -1) allKeys[prevIndex] = location.key;
+            setState({
+              action: action,
+              location: location,
+            });
+          }
         } else {
-          var prevIndex = allKeys.indexOf(history.location.key);
-          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
-          setState({
-            action: action,
-            location: location
-          });
+          process.env.NODE_ENV !== "production"
+            ? warning(
+                state === undefined,
+                "Browser history cannot replace state in browsers that do not support HTML5 history"
+              )
+            : void 0;
+          window.location.replace(href);
         }
-      } else {
-        process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : void 0;
-        window.location.replace(href);
       }
-    });
+    );
   }
 
   function go(n) {
@@ -430,10 +535,12 @@ function createBrowserHistory(props) {
 
     if (listenerCount === 1 && delta === 1) {
       window.addEventListener(PopStateEvent, handlePopState);
-      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
+      if (needsHashChangeListener)
+        window.addEventListener(HashChangeEvent, handleHashChange);
     } else if (listenerCount === 0) {
       window.removeEventListener(PopStateEvent, handlePopState);
-      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
+      if (needsHashChangeListener)
+        window.removeEventListener(HashChangeEvent, handleHashChange);
     }
   }
 
@@ -472,7 +579,7 @@ function createBrowserHistory(props) {
 
   var history = {
     length: globalHistory.length,
-    action: 'POP',
+    action: "POP",
     location: initialLocation,
     createHref: createHref,
     push: push,
@@ -481,33 +588,33 @@ function createBrowserHistory(props) {
     goBack: goBack,
     goForward: goForward,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
 
-var HashChangeEvent$1 = 'hashchange';
+var HashChangeEvent$1 = "hashchange";
 var HashPathCoders = {
   hashbang: {
     encodePath: function encodePath(path) {
-      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
+      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
     },
     decodePath: function decodePath(path) {
-      return path.charAt(0) === '!' ? path.substr(1) : path;
-    }
+      return path.charAt(0) === "!" ? path.substr(1) : path;
+    },
   },
   noslash: {
     encodePath: stripLeadingSlash,
-    decodePath: addLeadingSlash
+    decodePath: addLeadingSlash,
   },
   slash: {
     encodePath: addLeadingSlash,
-    decodePath: addLeadingSlash
-  }
+    decodePath: addLeadingSlash,
+  },
 };
 
 function stripHash(url) {
-  var hashIndex = url.indexOf('#');
+  var hashIndex = url.indexOf("#");
   return hashIndex === -1 ? url : url.slice(0, hashIndex);
 }
 
@@ -515,8 +622,8 @@ function getHashPath() {
   // We can't use window.location.hash here because it's not
   // consistent across browsers - Firefox will pre-decode it!
   var href = window.location.href;
-  var hashIndex = href.indexOf('#');
-  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
+  var hashIndex = href.indexOf("#");
+  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
 }
 
 function pushHashPath(path) {
@@ -524,7 +631,7 @@ function pushHashPath(path) {
 }
 
 function replaceHashPath(path) {
-  window.location.replace(stripHash(window.location.href) + '#' + path);
+  window.location.replace(stripHash(window.location.href) + "#" + path);
 }
 
 function createHashHistory(props) {
@@ -532,22 +639,41 @@ function createHashHistory(props) {
     props = {};
   }
 
-  !canUseDOM ? process.env.NODE_ENV !== "production" ? invariant(false, 'Hash history needs a DOM') : invariant(false) : void 0;
+  !canUseDOM
+    ? process.env.NODE_ENV !== "production"
+      ? invariant(false, "Hash history needs a DOM")
+      : invariant(false)
+    : void 0;
   var globalHistory = window.history;
   var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
   var _props = props,
-      _props$getUserConfirm = _props.getUserConfirmation,
-      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-      _props$hashType = _props.hashType,
-      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
-  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+    _props$getUserConfirm = _props.getUserConfirmation,
+    getUserConfirmation =
+      _props$getUserConfirm === void 0
+        ? getConfirmation
+        : _props$getUserConfirm,
+    _props$hashType = _props.hashType,
+    hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
+  var basename = props.basename
+    ? stripTrailingSlash(addLeadingSlash(props.basename))
+    : "";
   var _HashPathCoders$hashT = HashPathCoders[hashType],
-      encodePath = _HashPathCoders$hashT.encodePath,
-      decodePath = _HashPathCoders$hashT.decodePath;
+    encodePath = _HashPathCoders$hashT.encodePath,
+    decodePath = _HashPathCoders$hashT.decodePath;
 
   function getDOMLocation() {
     var path = decodePath(getHashPath());
-    process.env.NODE_ENV !== "production" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !basename || hasBasename(path, basename),
+          "You are attempting to use a basename on a page whose URL path does not begin " +
+            'with the basename. Expected path "' +
+            path +
+            '" to begin with "' +
+            basename +
+            '".'
+        )
+      : void 0;
     if (basename) path = stripBasename(path, basename);
     return createLocation(path);
   }
@@ -565,7 +691,9 @@ function createHashHistory(props) {
   var ignorePath = null;
 
   function locationsAreEqual$$1(a, b) {
-    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
+    return (
+      a.pathname === b.pathname && a.search === b.search && a.hash === b.hash
+    );
   }
 
   function handleHashChange() {
@@ -592,17 +720,22 @@ function createHashHistory(props) {
       forceNextPop = false;
       setState();
     } else {
-      var action = 'POP';
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (ok) {
-          setState({
-            action: action,
-            location: location
-          });
-        } else {
-          revertPop(location);
+      var action = "POP";
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (ok) {
+            setState({
+              action: action,
+              location: location,
+            });
+          } else {
+            revertPop(location);
+          }
         }
-      });
+      );
     }
   }
 
@@ -623,7 +756,6 @@ function createHashHistory(props) {
     }
   } // Ensure the hash is encoded properly before doing anything else.
 
-
   var path = getHashPath();
   var encodedPath = encodePath(path);
   if (path !== encodedPath) replaceHashPath(encodedPath);
@@ -631,76 +763,106 @@ function createHashHistory(props) {
   var allPaths = [createPath(initialLocation)]; // Public interface
 
   function createHref(location) {
-    var baseTag = document.querySelector('base');
-    var href = '';
+    var baseTag = document.querySelector("base");
+    var href = "";
 
-    if (baseTag && baseTag.getAttribute('href')) {
+    if (baseTag && baseTag.getAttribute("href")) {
       href = stripHash(window.location.href);
     }
 
-    return href + '#' + encodePath(basename + createPath(location));
+    return href + "#" + encodePath(basename + createPath(location));
   }
 
   function push(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Hash history cannot push state; it is ignored') : void 0;
-    var action = 'PUSH';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          state === undefined,
+          "Hash history cannot push state; it is ignored"
+        )
+      : void 0;
+    var action = "PUSH";
     var location = createLocation(path, undefined, undefined, history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var path = createPath(location);
-      var encodedPath = encodePath(basename + path);
-      var hashChanged = getHashPath() !== encodedPath;
-
-      if (hashChanged) {
-        // We cannot tell if a hashchange was caused by a PUSH, so we'd
-        // rather setState here and ignore the hashchange. The caveat here
-        // is that other hash histories in the page will consider it a POP.
-        ignorePath = path;
-        pushHashPath(encodedPath);
-        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
-        var nextPaths = allPaths.slice(0, prevIndex + 1);
-        nextPaths.push(path);
-        allPaths = nextPaths;
-        setState({
-          action: action,
-          location: location
-        });
-      } else {
-        process.env.NODE_ENV !== "production" ? warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : void 0;
-        setState();
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var path = createPath(location);
+        var encodedPath = encodePath(basename + path);
+        var hashChanged = getHashPath() !== encodedPath;
+
+        if (hashChanged) {
+          // We cannot tell if a hashchange was caused by a PUSH, so we'd
+          // rather setState here and ignore the hashchange. The caveat here
+          // is that other hash histories in the page will consider it a POP.
+          ignorePath = path;
+          pushHashPath(encodedPath);
+          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
+          var nextPaths = allPaths.slice(0, prevIndex + 1);
+          nextPaths.push(path);
+          allPaths = nextPaths;
+          setState({
+            action: action,
+            location: location,
+          });
+        } else {
+          process.env.NODE_ENV !== "production"
+            ? warning(
+                false,
+                "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"
+              )
+            : void 0;
+          setState();
+        }
       }
-    });
+    );
   }
 
   function replace(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Hash history cannot replace state; it is ignored') : void 0;
-    var action = 'REPLACE';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          state === undefined,
+          "Hash history cannot replace state; it is ignored"
+        )
+      : void 0;
+    var action = "REPLACE";
     var location = createLocation(path, undefined, undefined, history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var path = createPath(location);
-      var encodedPath = encodePath(basename + path);
-      var hashChanged = getHashPath() !== encodedPath;
-
-      if (hashChanged) {
-        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
-        // rather setState here and ignore the hashchange. The caveat here
-        // is that other hash histories in the page will consider it a POP.
-        ignorePath = path;
-        replaceHashPath(encodedPath);
-      }
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var path = createPath(location);
+        var encodedPath = encodePath(basename + path);
+        var hashChanged = getHashPath() !== encodedPath;
+
+        if (hashChanged) {
+          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
+          // rather setState here and ignore the hashchange. The caveat here
+          // is that other hash histories in the page will consider it a POP.
+          ignorePath = path;
+          replaceHashPath(encodedPath);
+        }
 
-      var prevIndex = allPaths.indexOf(createPath(history.location));
-      if (prevIndex !== -1) allPaths[prevIndex] = path;
-      setState({
-        action: action,
-        location: location
-      });
-    });
+        var prevIndex = allPaths.indexOf(createPath(history.location));
+        if (prevIndex !== -1) allPaths[prevIndex] = path;
+        setState({
+          action: action,
+          location: location,
+        });
+      }
+    );
   }
 
   function go(n) {
-    process.env.NODE_ENV !== "production" ? warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          canGoWithoutReload,
+          "Hash history go(n) causes a full page reload in this browser"
+        )
+      : void 0;
     globalHistory.go(n);
   }
 
@@ -759,7 +921,7 @@ function createHashHistory(props) {
 
   var history = {
     length: globalHistory.length,
-    action: 'POP',
+    action: "POP",
     location: initialLocation,
     createHref: createHref,
     push: push,
@@ -768,7 +930,7 @@ function createHashHistory(props) {
     goBack: goBack,
     goForward: goForward,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
@@ -780,20 +942,20 @@ function clamp(n, lowerBound, upperBound) {
  * Creates a history object that stores locations in memory.
  */
 
-
 function createMemoryHistory(props) {
   if (props === void 0) {
     props = {};
   }
 
   var _props = props,
-      getUserConfirmation = _props.getUserConfirmation,
-      _props$initialEntries = _props.initialEntries,
-      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
-      _props$initialIndex = _props.initialIndex,
-      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
-      _props$keyLength = _props.keyLength,
-      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+    getUserConfirmation = _props.getUserConfirmation,
+    _props$initialEntries = _props.initialEntries,
+    initialEntries =
+      _props$initialEntries === void 0 ? ["/"] : _props$initialEntries,
+    _props$initialIndex = _props.initialIndex,
+    initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
+    _props$keyLength = _props.keyLength,
+    keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
   var transitionManager = createTransitionManager();
 
   function setState(nextState) {
@@ -809,67 +971,108 @@ function createMemoryHistory(props) {
 
   var index = clamp(initialIndex, 0, initialEntries.length - 1);
   var entries = initialEntries.map(function (entry) {
-    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
+    return typeof entry === "string"
+      ? createLocation(entry, undefined, createKey())
+      : createLocation(entry, undefined, entry.key || createKey());
   }); // Public interface
 
   var createHref = createPath;
 
   function push(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
-    var action = 'PUSH';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !(
+            typeof path === "object" &&
+            path.state !== undefined &&
+            state !== undefined
+          ),
+          "You should avoid providing a 2nd state argument to push when the 1st " +
+            "argument is a location-like object that already has state; it is ignored"
+        )
+      : void 0;
+    var action = "PUSH";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      var prevIndex = history.index;
-      var nextIndex = prevIndex + 1;
-      var nextEntries = history.entries.slice(0);
-
-      if (nextEntries.length > nextIndex) {
-        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
-      } else {
-        nextEntries.push(location);
-      }
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        var prevIndex = history.index;
+        var nextIndex = prevIndex + 1;
+        var nextEntries = history.entries.slice(0);
+
+        if (nextEntries.length > nextIndex) {
+          nextEntries.splice(
+            nextIndex,
+            nextEntries.length - nextIndex,
+            location
+          );
+        } else {
+          nextEntries.push(location);
+        }
 
-      setState({
-        action: action,
-        location: location,
-        index: nextIndex,
-        entries: nextEntries
-      });
-    });
+        setState({
+          action: action,
+          location: location,
+          index: nextIndex,
+          entries: nextEntries,
+        });
+      }
+    );
   }
 
   function replace(path, state) {
-    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
-    var action = 'REPLACE';
+    process.env.NODE_ENV !== "production"
+      ? warning(
+          !(
+            typeof path === "object" &&
+            path.state !== undefined &&
+            state !== undefined
+          ),
+          "You should avoid providing a 2nd state argument to replace when the 1st " +
+            "argument is a location-like object that already has state; it is ignored"
+        )
+      : void 0;
+    var action = "REPLACE";
     var location = createLocation(path, state, createKey(), history.location);
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (!ok) return;
-      history.entries[history.index] = location;
-      setState({
-        action: action,
-        location: location
-      });
-    });
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (!ok) return;
+        history.entries[history.index] = location;
+        setState({
+          action: action,
+          location: location,
+        });
+      }
+    );
   }
 
   function go(n) {
     var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
-    var action = 'POP';
+    var action = "POP";
     var location = history.entries[nextIndex];
-    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-      if (ok) {
-        setState({
-          action: action,
-          location: location,
-          index: nextIndex
-        });
-      } else {
-        // Mimic the behavior of DOM histories by
-        // causing a render after a cancelled POP.
-        setState();
+    transitionManager.confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      function (ok) {
+        if (ok) {
+          setState({
+            action: action,
+            location: location,
+            index: nextIndex,
+          });
+        } else {
+          // Mimic the behavior of DOM histories by
+          // causing a render after a cancelled POP.
+          setState();
+        }
       }
-    });
+    );
   }
 
   function goBack() {
@@ -899,7 +1102,7 @@ function createMemoryHistory(props) {
 
   var history = {
     length: entries.length,
-    action: 'POP',
+    action: "POP",
     location: entries[index],
     index: index,
     entries: entries,
@@ -911,9 +1114,17 @@ function createMemoryHistory(props) {
     goForward: goForward,
     canGo: canGo,
     block: block,
-    listen: listen
+    listen: listen,
   };
   return history;
 }
 
-export { createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath };
+export {
+  createBrowserHistory,
+  createHashHistory,
+  createMemoryHistory,
+  createLocation,
+  locationsAreEqual,
+  parsePath,
+  createPath,
+};
diff --git a/umd/history.js b/umd/history.js
index 80e4ff66c44a2a71d4f842cc05a252e48dd18e9a..4af51bae1874ce1a732134aed45c9764cb3c2008 100644
--- a/umd/history.js
+++ b/umd/history.js
@@ -1,29 +1,34 @@
 (function (global, factory) {
-  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
-  typeof define === 'function' && define.amd ? define(['exports'], factory) :
-  (factory((global.History = {})));
-}(this, (function (exports) { 'use strict';
+  typeof exports === "object" && typeof module !== "undefined"
+    ? factory(exports)
+    : typeof define === "function" && define.amd
+    ? define(["exports"], factory)
+    : factory((global.History = {}));
+})(this, function (exports) {
+  "use strict";
 
   function _extends() {
-    _extends = Object.assign || function (target) {
-      for (var i = 1; i < arguments.length; i++) {
-        var source = arguments[i];
-
-        for (var key in source) {
-          if (Object.prototype.hasOwnProperty.call(source, key)) {
-            target[key] = source[key];
+    _extends =
+      Object.assign ||
+      function (target) {
+        for (var i = 1; i < arguments.length; i++) {
+          var source = arguments[i];
+
+          for (var key in source) {
+            if (Object.prototype.hasOwnProperty.call(source, key)) {
+              target[key] = source[key];
+            }
           }
         }
-      }
 
-      return target;
-    };
+        return target;
+      };
 
     return _extends.apply(this, arguments);
   }
 
   function isAbsolute(pathname) {
-    return pathname.charAt(0) === '/';
+    return pathname.charAt(0) === "/";
   }
 
   // About 1.5x faster than the two-arg version of Array#splice()
@@ -37,10 +42,10 @@
 
   // This implementation is based heavily on node's url.parse
   function resolvePathname(to, from) {
-    if (from === undefined) from = '';
+    if (from === undefined) from = "";
 
-    var toParts = (to && to.split('/')) || [];
-    var fromParts = (from && from.split('/')) || [];
+    var toParts = (to && to.split("/")) || [];
+    var fromParts = (from && from.split("/")) || [];
 
     var isToAbs = to && isAbsolute(to);
     var isFromAbs = from && isAbsolute(from);
@@ -55,12 +60,12 @@
       fromParts = fromParts.concat(toParts);
     }
 
-    if (!fromParts.length) return '/';
+    if (!fromParts.length) return "/";
 
     var hasTrailingSlash;
     if (fromParts.length) {
       var last = fromParts[fromParts.length - 1];
-      hasTrailingSlash = last === '.' || last === '..' || last === '';
+      hasTrailingSlash = last === "." || last === ".." || last === "";
     } else {
       hasTrailingSlash = false;
     }
@@ -69,9 +74,9 @@
     for (var i = fromParts.length; i >= 0; i--) {
       var part = fromParts[i];
 
-      if (part === '.') {
+      if (part === ".") {
         spliceOne(fromParts, i);
-      } else if (part === '..') {
+      } else if (part === "..") {
         spliceOne(fromParts, i);
         up++;
       } else if (up) {
@@ -80,18 +85,18 @@
       }
     }
 
-    if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');
+    if (!mustEndAbs) for (; up--; up) fromParts.unshift("..");
 
     if (
       mustEndAbs &&
-      fromParts[0] !== '' &&
+      fromParts[0] !== "" &&
       (!fromParts[0] || !isAbsolute(fromParts[0]))
     )
-      fromParts.unshift('');
+      fromParts.unshift("");
 
-    var result = fromParts.join('/');
+    var result = fromParts.join("/");
 
-    if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';
+    if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
 
     return result;
   }
@@ -111,19 +116,19 @@
       return (
         Array.isArray(b) &&
         a.length === b.length &&
-        a.every(function(item, index) {
+        a.every(function (item, index) {
           return valueEqual(item, b[index]);
         })
       );
     }
 
-    if (typeof a === 'object' || typeof b === 'object') {
+    if (typeof a === "object" || typeof b === "object") {
       var aValue = valueOf(a);
       var bValue = valueOf(b);
 
       if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
 
-      return Object.keys(Object.assign({}, a, b)).every(function(key) {
+      return Object.keys(Object.assign({}, a, b)).every(function (key) {
         return valueEqual(a[key], b[key]);
       });
     }
@@ -132,32 +137,35 @@
   }
 
   function addLeadingSlash(path) {
-    return path.charAt(0) === '/' ? path : '/' + path;
+    return path.charAt(0) === "/" ? path : "/" + path;
   }
   function stripLeadingSlash(path) {
-    return path.charAt(0) === '/' ? path.substr(1) : path;
+    return path.charAt(0) === "/" ? path.substr(1) : path;
   }
   function hasBasename(path, prefix) {
-    return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
+    return (
+      path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 &&
+      "/?#".indexOf(path.charAt(prefix.length)) !== -1
+    );
   }
   function stripBasename(path, prefix) {
     return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
   }
   function stripTrailingSlash(path) {
-    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
+    return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
   }
   function parsePath(path) {
-    var pathname = path || '/';
-    var search = '';
-    var hash = '';
-    var hashIndex = pathname.indexOf('#');
+    var pathname = path || "/";
+    var search = "";
+    var hash = "";
+    var hashIndex = pathname.indexOf("#");
 
     if (hashIndex !== -1) {
       hash = pathname.substr(hashIndex);
       pathname = pathname.substr(0, hashIndex);
     }
 
-    var searchIndex = pathname.indexOf('?');
+    var searchIndex = pathname.indexOf("?");
 
     if (searchIndex !== -1) {
       search = pathname.substr(searchIndex);
@@ -166,55 +174,50 @@
 
     return {
       pathname: pathname,
-      search: search === '?' ? '' : search,
-      hash: hash === '#' ? '' : hash
+      search: search === "?" ? "" : search,
+      hash: hash === "#" ? "" : hash,
     };
   }
   function createPath(location) {
     var pathname = location.pathname,
-        search = location.search,
-        hash = location.hash;
-    var path = pathname || '/';
-    if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
-    if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
+      search = location.search,
+      hash = location.hash;
+    var path = pathname || "/";
+    if (search && search !== "?")
+      path += search.charAt(0) === "?" ? search : "?" + search;
+    if (hash && hash !== "#")
+      path += hash.charAt(0) === "#" ? hash : "#" + hash;
     return path;
   }
 
   function createLocation(path, state, key, currentLocation) {
     var location;
 
-    if (typeof path === 'string') {
+    if (typeof path === "string") {
       // Two-arg form: push(path, state)
       location = parsePath(path);
       location.state = state;
     } else {
       // One-arg form: push(location)
       location = _extends({}, path);
-      if (location.pathname === undefined) location.pathname = '';
+      if (location.pathname === undefined) location.pathname = "";
 
       if (location.search) {
-        if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
+        if (location.search.charAt(0) !== "?")
+          location.search = "?" + location.search;
       } else {
-        location.search = '';
+        location.search = "";
       }
 
       if (location.hash) {
-        if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
+        if (location.hash.charAt(0) !== "#")
+          location.hash = "#" + location.hash;
       } else {
-        location.hash = '';
+        location.hash = "";
       }
 
-      if (state !== undefined && location.state === undefined) location.state = state;
-    }
-
-    try {
-      location.pathname = decodeURI(location.pathname);
-    } catch (e) {
-      if (e instanceof URIError) {
-        throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
-      } else {
-        throw e;
-      }
+      if (state !== undefined && location.state === undefined)
+        location.state = state;
     }
 
     if (key) location.key = key;
@@ -223,20 +226,29 @@
       // Resolve incomplete/relative pathname relative to current location.
       if (!location.pathname) {
         location.pathname = currentLocation.pathname;
-      } else if (location.pathname.charAt(0) !== '/') {
-        location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
+      } else if (location.pathname.charAt(0) !== "/") {
+        location.pathname = resolvePathname(
+          location.pathname,
+          currentLocation.pathname
+        );
       }
     } else {
       // When there is no prior location and pathname is empty, set it to /
       if (!location.pathname) {
-        location.pathname = '/';
+        location.pathname = "/";
       }
     }
 
     return location;
   }
   function locationsAreEqual(a, b) {
-    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
+    return (
+      a.pathname === b.pathname &&
+      a.search === b.search &&
+      a.hash === b.hash &&
+      a.key === b.key &&
+      valueEqual(a.state, b.state)
+    );
   }
 
   function warning(condition, message) {
@@ -247,7 +259,7 @@
 
       var text = "Warning: " + message;
 
-      if (typeof console !== 'undefined') {
+      if (typeof console !== "undefined") {
         console.warn(text);
       }
 
@@ -261,25 +273,34 @@
     var prompt = null;
 
     function setPrompt(nextPrompt) {
-      warning(prompt == null, 'A history supports only one prompt at a time');
+      warning(prompt == null, "A history supports only one prompt at a time");
       prompt = nextPrompt;
       return function () {
         if (prompt === nextPrompt) prompt = null;
       };
     }
 
-    function confirmTransitionTo(location, action, getUserConfirmation, callback) {
+    function confirmTransitionTo(
+      location,
+      action,
+      getUserConfirmation,
+      callback
+    ) {
       // TODO: If another transition starts while we're still confirming
       // the previous one, we may end up in a weird state. Figure out the
       // best way to handle this.
       if (prompt != null) {
-        var result = typeof prompt === 'function' ? prompt(location, action) : prompt;
+        var result =
+          typeof prompt === "function" ? prompt(location, action) : prompt;
 
-        if (typeof result === 'string') {
-          if (typeof getUserConfirmation === 'function') {
+        if (typeof result === "string") {
+          if (typeof getUserConfirmation === "function") {
             getUserConfirmation(result, callback);
           } else {
-            warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
+            warning(
+              false,
+              "A history needs a getUserConfirmation function in order to use a prompt message"
+            );
             callback(true);
           }
         } else {
@@ -310,7 +331,11 @@
     }
 
     function notifyListeners() {
-      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+      for (
+        var _len = arguments.length, args = new Array(_len), _key = 0;
+        _key < _len;
+        _key++
+      ) {
         args[_key] = arguments[_key];
       }
 
@@ -323,11 +348,15 @@
       setPrompt: setPrompt,
       confirmTransitionTo: confirmTransitionTo,
       appendListener: appendListener,
-      notifyListeners: notifyListeners
+      notifyListeners: notifyListeners,
     };
   }
 
-  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
+  var canUseDOM = !!(
+    typeof window !== "undefined" &&
+    window.document &&
+    window.document.createElement
+  );
   function getConfirmation(message, callback) {
     callback(window.confirm(message)); // eslint-disable-line no-alert
   }
@@ -341,8 +370,14 @@
 
   function supportsHistory() {
     var ua = window.navigator.userAgent;
-    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
-    return window.history && 'pushState' in window.history;
+    if (
+      (ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) &&
+      ua.indexOf("Mobile Safari") !== -1 &&
+      ua.indexOf("Chrome") === -1 &&
+      ua.indexOf("Windows Phone") === -1
+    )
+      return false;
+    return window.history && "pushState" in window.history;
   }
   /**
    * Returns true if browser fires popstate on hash change.
@@ -350,14 +385,14 @@
    */
 
   function supportsPopStateOnHashChange() {
-    return window.navigator.userAgent.indexOf('Trident') === -1;
+    return window.navigator.userAgent.indexOf("Trident") === -1;
   }
   /**
    * Returns false if using go(n) with hash history causes a full page reload.
    */
 
   function supportsGoWithoutReloadUsingHash() {
-    return window.navigator.userAgent.indexOf('Firefox') === -1;
+    return window.navigator.userAgent.indexOf("Firefox") === -1;
   }
   /**
    * Returns true if a given popstate event is an extraneous WebKit event.
@@ -366,22 +401,24 @@
    */
 
   function isExtraneousPopstateEvent(event) {
-    return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
+    return (
+      event.state === undefined && navigator.userAgent.indexOf("CriOS") === -1
+    );
   }
 
-  var prefix = 'Invariant failed';
+  var prefix = "Invariant failed";
   function invariant(condition, message) {
     if (condition) {
       return;
     }
 
     {
-      throw new Error(prefix + ": " + (message || ''));
+      throw new Error(prefix + ": " + (message || ""));
     }
   }
 
-  var PopStateEvent = 'popstate';
-  var HashChangeEvent = 'hashchange';
+  var PopStateEvent = "popstate";
+  var HashChangeEvent = "hashchange";
 
   function getHistoryState() {
     try {
@@ -397,36 +434,49 @@
    * pushState, replaceState, and the popstate event.
    */
 
-
   function createBrowserHistory(props) {
     if (props === void 0) {
       props = {};
     }
 
-    !canUseDOM ? invariant(false, 'Browser history needs a DOM') : void 0;
+    !canUseDOM ? invariant(false, "Browser history needs a DOM") : void 0;
     var globalHistory = window.history;
     var canUseHistory = supportsHistory();
     var needsHashChangeListener = !supportsPopStateOnHashChange();
     var _props = props,
-        _props$forceRefresh = _props.forceRefresh,
-        forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
-        _props$getUserConfirm = _props.getUserConfirmation,
-        getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-        _props$keyLength = _props.keyLength,
-        keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
-    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+      _props$forceRefresh = _props.forceRefresh,
+      forceRefresh =
+        _props$forceRefresh === void 0 ? false : _props$forceRefresh,
+      _props$getUserConfirm = _props.getUserConfirmation,
+      getUserConfirmation =
+        _props$getUserConfirm === void 0
+          ? getConfirmation
+          : _props$getUserConfirm,
+      _props$keyLength = _props.keyLength,
+      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+    var basename = props.basename
+      ? stripTrailingSlash(addLeadingSlash(props.basename))
+      : "";
 
     function getDOMLocation(historyState) {
       var _ref = historyState || {},
-          key = _ref.key,
-          state = _ref.state;
+        key = _ref.key,
+        state = _ref.state;
 
       var _window$location = window.location,
-          pathname = _window$location.pathname,
-          search = _window$location.search,
-          hash = _window$location.hash;
+        pathname = _window$location.pathname,
+        search = _window$location.search,
+        hash = _window$location.hash;
       var path = pathname + search + hash;
-      warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
+      warning(
+        !basename || hasBasename(path, basename),
+        "You are attempting to use a basename on a page whose URL path does not begin " +
+          'with the basename. Expected path "' +
+          path +
+          '" to begin with "' +
+          basename +
+          '".'
+      );
       if (basename) path = stripBasename(path, basename);
       return createLocation(path, state, key);
     }
@@ -461,17 +511,22 @@
         forceNextPop = false;
         setState();
       } else {
-        var action = 'POP';
-        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-          if (ok) {
-            setState({
-              action: action,
-              location: location
-            });
-          } else {
-            revertPop(location);
+        var action = "POP";
+        transitionManager.confirmTransitionTo(
+          location,
+          action,
+          getUserConfirmation,
+          function (ok) {
+            if (ok) {
+              setState({
+                action: action,
+                location: location,
+              });
+            } else {
+              revertPop(location);
+            }
           }
-        });
+        );
       }
     }
 
@@ -500,71 +555,111 @@
     }
 
     function push(path, state) {
-      warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-      var action = 'PUSH';
+      warning(
+        !(
+          typeof path === "object" &&
+          path.state !== undefined &&
+          state !== undefined
+        ),
+        "You should avoid providing a 2nd state argument to push when the 1st " +
+          "argument is a location-like object that already has state; it is ignored"
+      );
+      var action = "PUSH";
       var location = createLocation(path, state, createKey(), history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        var href = createHref(location);
-        var key = location.key,
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          var href = createHref(location);
+          var key = location.key,
             state = location.state;
 
-        if (canUseHistory) {
-          globalHistory.pushState({
-            key: key,
-            state: state
-          }, null, href);
-
-          if (forceRefresh) {
-            window.location.href = href;
+          if (canUseHistory) {
+            globalHistory.pushState(
+              {
+                key: key,
+                state: state,
+              },
+              null,
+              href
+            );
+
+            if (forceRefresh) {
+              window.location.href = href;
+            } else {
+              var prevIndex = allKeys.indexOf(history.location.key);
+              var nextKeys = allKeys.slice(0, prevIndex + 1);
+              nextKeys.push(location.key);
+              allKeys = nextKeys;
+              setState({
+                action: action,
+                location: location,
+              });
+            }
           } else {
-            var prevIndex = allKeys.indexOf(history.location.key);
-            var nextKeys = allKeys.slice(0, prevIndex + 1);
-            nextKeys.push(location.key);
-            allKeys = nextKeys;
-            setState({
-              action: action,
-              location: location
-            });
+            warning(
+              state === undefined,
+              "Browser history cannot push state in browsers that do not support HTML5 history"
+            );
+            window.location.href = href;
           }
-        } else {
-          warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');
-          window.location.href = href;
         }
-      });
+      );
     }
 
     function replace(path, state) {
-      warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-      var action = 'REPLACE';
+      warning(
+        !(
+          typeof path === "object" &&
+          path.state !== undefined &&
+          state !== undefined
+        ),
+        "You should avoid providing a 2nd state argument to replace when the 1st " +
+          "argument is a location-like object that already has state; it is ignored"
+      );
+      var action = "REPLACE";
       var location = createLocation(path, state, createKey(), history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        var href = createHref(location);
-        var key = location.key,
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          var href = createHref(location);
+          var key = location.key,
             state = location.state;
 
-        if (canUseHistory) {
-          globalHistory.replaceState({
-            key: key,
-            state: state
-          }, null, href);
-
-          if (forceRefresh) {
-            window.location.replace(href);
+          if (canUseHistory) {
+            globalHistory.replaceState(
+              {
+                key: key,
+                state: state,
+              },
+              null,
+              href
+            );
+
+            if (forceRefresh) {
+              window.location.replace(href);
+            } else {
+              var prevIndex = allKeys.indexOf(history.location.key);
+              if (prevIndex !== -1) allKeys[prevIndex] = location.key;
+              setState({
+                action: action,
+                location: location,
+              });
+            }
           } else {
-            var prevIndex = allKeys.indexOf(history.location.key);
-            if (prevIndex !== -1) allKeys[prevIndex] = location.key;
-            setState({
-              action: action,
-              location: location
-            });
+            warning(
+              state === undefined,
+              "Browser history cannot replace state in browsers that do not support HTML5 history"
+            );
+            window.location.replace(href);
           }
-        } else {
-          warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');
-          window.location.replace(href);
         }
-      });
+      );
     }
 
     function go(n) {
@@ -586,10 +681,12 @@
 
       if (listenerCount === 1 && delta === 1) {
         window.addEventListener(PopStateEvent, handlePopState);
-        if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
+        if (needsHashChangeListener)
+          window.addEventListener(HashChangeEvent, handleHashChange);
       } else if (listenerCount === 0) {
         window.removeEventListener(PopStateEvent, handlePopState);
-        if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
+        if (needsHashChangeListener)
+          window.removeEventListener(HashChangeEvent, handleHashChange);
       }
     }
 
@@ -628,7 +725,7 @@
 
     var history = {
       length: globalHistory.length,
-      action: 'POP',
+      action: "POP",
       location: initialLocation,
       createHref: createHref,
       push: push,
@@ -637,33 +734,33 @@
       goBack: goBack,
       goForward: goForward,
       block: block,
-      listen: listen
+      listen: listen,
     };
     return history;
   }
 
-  var HashChangeEvent$1 = 'hashchange';
+  var HashChangeEvent$1 = "hashchange";
   var HashPathCoders = {
     hashbang: {
       encodePath: function encodePath(path) {
-        return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
+        return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
       },
       decodePath: function decodePath(path) {
-        return path.charAt(0) === '!' ? path.substr(1) : path;
-      }
+        return path.charAt(0) === "!" ? path.substr(1) : path;
+      },
     },
     noslash: {
       encodePath: stripLeadingSlash,
-      decodePath: addLeadingSlash
+      decodePath: addLeadingSlash,
     },
     slash: {
       encodePath: addLeadingSlash,
-      decodePath: addLeadingSlash
-    }
+      decodePath: addLeadingSlash,
+    },
   };
 
   function stripHash(url) {
-    var hashIndex = url.indexOf('#');
+    var hashIndex = url.indexOf("#");
     return hashIndex === -1 ? url : url.slice(0, hashIndex);
   }
 
@@ -671,8 +768,8 @@
     // We can't use window.location.hash here because it's not
     // consistent across browsers - Firefox will pre-decode it!
     var href = window.location.href;
-    var hashIndex = href.indexOf('#');
-    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
+    var hashIndex = href.indexOf("#");
+    return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
   }
 
   function pushHashPath(path) {
@@ -680,7 +777,7 @@
   }
 
   function replaceHashPath(path) {
-    window.location.replace(stripHash(window.location.href) + '#' + path);
+    window.location.replace(stripHash(window.location.href) + "#" + path);
   }
 
   function createHashHistory(props) {
@@ -688,22 +785,35 @@
       props = {};
     }
 
-    !canUseDOM ? invariant(false, 'Hash history needs a DOM') : void 0;
+    !canUseDOM ? invariant(false, "Hash history needs a DOM") : void 0;
     var globalHistory = window.history;
     var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
     var _props = props,
-        _props$getUserConfirm = _props.getUserConfirmation,
-        getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
-        _props$hashType = _props.hashType,
-        hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
-    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
+      _props$getUserConfirm = _props.getUserConfirmation,
+      getUserConfirmation =
+        _props$getUserConfirm === void 0
+          ? getConfirmation
+          : _props$getUserConfirm,
+      _props$hashType = _props.hashType,
+      hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
+    var basename = props.basename
+      ? stripTrailingSlash(addLeadingSlash(props.basename))
+      : "";
     var _HashPathCoders$hashT = HashPathCoders[hashType],
-        encodePath = _HashPathCoders$hashT.encodePath,
-        decodePath = _HashPathCoders$hashT.decodePath;
+      encodePath = _HashPathCoders$hashT.encodePath,
+      decodePath = _HashPathCoders$hashT.decodePath;
 
     function getDOMLocation() {
       var path = decodePath(getHashPath());
-      warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
+      warning(
+        !basename || hasBasename(path, basename),
+        "You are attempting to use a basename on a page whose URL path does not begin " +
+          'with the basename. Expected path "' +
+          path +
+          '" to begin with "' +
+          basename +
+          '".'
+      );
       if (basename) path = stripBasename(path, basename);
       return createLocation(path);
     }
@@ -721,7 +831,9 @@
     var ignorePath = null;
 
     function locationsAreEqual$$1(a, b) {
-      return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
+      return (
+        a.pathname === b.pathname && a.search === b.search && a.hash === b.hash
+      );
     }
 
     function handleHashChange() {
@@ -734,7 +846,8 @@
       } else {
         var location = getDOMLocation();
         var prevLocation = history.location;
-        if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.
+        if (!forceNextPop && locationsAreEqual$$1(prevLocation, location))
+          return; // A hashchange doesn't always == location change.
 
         if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.
 
@@ -748,17 +861,22 @@
         forceNextPop = false;
         setState();
       } else {
-        var action = 'POP';
-        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-          if (ok) {
-            setState({
-              action: action,
-              location: location
-            });
-          } else {
-            revertPop(location);
+        var action = "POP";
+        transitionManager.confirmTransitionTo(
+          location,
+          action,
+          getUserConfirmation,
+          function (ok) {
+            if (ok) {
+              setState({
+                action: action,
+                location: location,
+              });
+            } else {
+              revertPop(location);
+            }
           }
-        });
+        );
       }
     }
 
@@ -779,7 +897,6 @@
       }
     } // Ensure the hash is encoded properly before doing anything else.
 
-
     var path = getHashPath();
     var encodedPath = encodePath(path);
     if (path !== encodedPath) replaceHashPath(encodedPath);
@@ -787,76 +904,108 @@
     var allPaths = [createPath(initialLocation)]; // Public interface
 
     function createHref(location) {
-      var baseTag = document.querySelector('base');
-      var href = '';
+      var baseTag = document.querySelector("base");
+      var href = "";
 
-      if (baseTag && baseTag.getAttribute('href')) {
+      if (baseTag && baseTag.getAttribute("href")) {
         href = stripHash(window.location.href);
       }
 
-      return href + '#' + encodePath(basename + createPath(location));
+      return href + "#" + encodePath(basename + createPath(location));
     }
 
     function push(path, state) {
-      warning(state === undefined, 'Hash history cannot push state; it is ignored');
-      var action = 'PUSH';
-      var location = createLocation(path, undefined, undefined, history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        var path = createPath(location);
-        var encodedPath = encodePath(basename + path);
-        var hashChanged = getHashPath() !== encodedPath;
-
-        if (hashChanged) {
-          // We cannot tell if a hashchange was caused by a PUSH, so we'd
-          // rather setState here and ignore the hashchange. The caveat here
-          // is that other hash histories in the page will consider it a POP.
-          ignorePath = path;
-          pushHashPath(encodedPath);
-          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
-          var nextPaths = allPaths.slice(0, prevIndex + 1);
-          nextPaths.push(path);
-          allPaths = nextPaths;
-          setState({
-            action: action,
-            location: location
-          });
-        } else {
-          warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
-          setState();
+      warning(
+        state === undefined,
+        "Hash history cannot push state; it is ignored"
+      );
+      var action = "PUSH";
+      var location = createLocation(
+        path,
+        undefined,
+        undefined,
+        history.location
+      );
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          var path = createPath(location);
+          var encodedPath = encodePath(basename + path);
+          var hashChanged = getHashPath() !== encodedPath;
+
+          if (hashChanged) {
+            // We cannot tell if a hashchange was caused by a PUSH, so we'd
+            // rather setState here and ignore the hashchange. The caveat here
+            // is that other hash histories in the page will consider it a POP.
+            ignorePath = path;
+            pushHashPath(encodedPath);
+            var prevIndex = allPaths.lastIndexOf(createPath(history.location));
+            var nextPaths = allPaths.slice(0, prevIndex + 1);
+            nextPaths.push(path);
+            allPaths = nextPaths;
+            setState({
+              action: action,
+              location: location,
+            });
+          } else {
+            warning(
+              false,
+              "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"
+            );
+            setState();
+          }
         }
-      });
+      );
     }
 
     function replace(path, state) {
-      warning(state === undefined, 'Hash history cannot replace state; it is ignored');
-      var action = 'REPLACE';
-      var location = createLocation(path, undefined, undefined, history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        var path = createPath(location);
-        var encodedPath = encodePath(basename + path);
-        var hashChanged = getHashPath() !== encodedPath;
-
-        if (hashChanged) {
-          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
-          // rather setState here and ignore the hashchange. The caveat here
-          // is that other hash histories in the page will consider it a POP.
-          ignorePath = path;
-          replaceHashPath(encodedPath);
-        }
+      warning(
+        state === undefined,
+        "Hash history cannot replace state; it is ignored"
+      );
+      var action = "REPLACE";
+      var location = createLocation(
+        path,
+        undefined,
+        undefined,
+        history.location
+      );
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          var path = createPath(location);
+          var encodedPath = encodePath(basename + path);
+          var hashChanged = getHashPath() !== encodedPath;
+
+          if (hashChanged) {
+            // We cannot tell if a hashchange was caused by a REPLACE, so we'd
+            // rather setState here and ignore the hashchange. The caveat here
+            // is that other hash histories in the page will consider it a POP.
+            ignorePath = path;
+            replaceHashPath(encodedPath);
+          }
 
-        var prevIndex = allPaths.indexOf(createPath(history.location));
-        if (prevIndex !== -1) allPaths[prevIndex] = path;
-        setState({
-          action: action,
-          location: location
-        });
-      });
+          var prevIndex = allPaths.indexOf(createPath(history.location));
+          if (prevIndex !== -1) allPaths[prevIndex] = path;
+          setState({
+            action: action,
+            location: location,
+          });
+        }
+      );
     }
 
     function go(n) {
-      warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
+      warning(
+        canGoWithoutReload,
+        "Hash history go(n) causes a full page reload in this browser"
+      );
       globalHistory.go(n);
     }
 
@@ -915,7 +1064,7 @@
 
     var history = {
       length: globalHistory.length,
-      action: 'POP',
+      action: "POP",
       location: initialLocation,
       createHref: createHref,
       push: push,
@@ -924,7 +1073,7 @@
       goBack: goBack,
       goForward: goForward,
       block: block,
-      listen: listen
+      listen: listen,
     };
     return history;
   }
@@ -936,20 +1085,20 @@
    * Creates a history object that stores locations in memory.
    */
 
-
   function createMemoryHistory(props) {
     if (props === void 0) {
       props = {};
     }
 
     var _props = props,
-        getUserConfirmation = _props.getUserConfirmation,
-        _props$initialEntries = _props.initialEntries,
-        initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
-        _props$initialIndex = _props.initialIndex,
-        initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
-        _props$keyLength = _props.keyLength,
-        keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
+      getUserConfirmation = _props.getUserConfirmation,
+      _props$initialEntries = _props.initialEntries,
+      initialEntries =
+        _props$initialEntries === void 0 ? ["/"] : _props$initialEntries,
+      _props$initialIndex = _props.initialIndex,
+      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
+      _props$keyLength = _props.keyLength,
+      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
     var transitionManager = createTransitionManager();
 
     function setState(nextState) {
@@ -965,67 +1114,104 @@
 
     var index = clamp(initialIndex, 0, initialEntries.length - 1);
     var entries = initialEntries.map(function (entry) {
-      return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
+      return typeof entry === "string"
+        ? createLocation(entry, undefined, createKey())
+        : createLocation(entry, undefined, entry.key || createKey());
     }); // Public interface
 
     var createHref = createPath;
 
     function push(path, state) {
-      warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-      var action = 'PUSH';
+      warning(
+        !(
+          typeof path === "object" &&
+          path.state !== undefined &&
+          state !== undefined
+        ),
+        "You should avoid providing a 2nd state argument to push when the 1st " +
+          "argument is a location-like object that already has state; it is ignored"
+      );
+      var action = "PUSH";
       var location = createLocation(path, state, createKey(), history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        var prevIndex = history.index;
-        var nextIndex = prevIndex + 1;
-        var nextEntries = history.entries.slice(0);
-
-        if (nextEntries.length > nextIndex) {
-          nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
-        } else {
-          nextEntries.push(location);
-        }
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          var prevIndex = history.index;
+          var nextIndex = prevIndex + 1;
+          var nextEntries = history.entries.slice(0);
+
+          if (nextEntries.length > nextIndex) {
+            nextEntries.splice(
+              nextIndex,
+              nextEntries.length - nextIndex,
+              location
+            );
+          } else {
+            nextEntries.push(location);
+          }
 
-        setState({
-          action: action,
-          location: location,
-          index: nextIndex,
-          entries: nextEntries
-        });
-      });
+          setState({
+            action: action,
+            location: location,
+            index: nextIndex,
+            entries: nextEntries,
+          });
+        }
+      );
     }
 
     function replace(path, state) {
-      warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
-      var action = 'REPLACE';
+      warning(
+        !(
+          typeof path === "object" &&
+          path.state !== undefined &&
+          state !== undefined
+        ),
+        "You should avoid providing a 2nd state argument to replace when the 1st " +
+          "argument is a location-like object that already has state; it is ignored"
+      );
+      var action = "REPLACE";
       var location = createLocation(path, state, createKey(), history.location);
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (!ok) return;
-        history.entries[history.index] = location;
-        setState({
-          action: action,
-          location: location
-        });
-      });
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (!ok) return;
+          history.entries[history.index] = location;
+          setState({
+            action: action,
+            location: location,
+          });
+        }
+      );
     }
 
     function go(n) {
       var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
-      var action = 'POP';
+      var action = "POP";
       var location = history.entries[nextIndex];
-      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
-        if (ok) {
-          setState({
-            action: action,
-            location: location,
-            index: nextIndex
-          });
-        } else {
-          // Mimic the behavior of DOM histories by
-          // causing a render after a cancelled POP.
-          setState();
+      transitionManager.confirmTransitionTo(
+        location,
+        action,
+        getUserConfirmation,
+        function (ok) {
+          if (ok) {
+            setState({
+              action: action,
+              location: location,
+              index: nextIndex,
+            });
+          } else {
+            // Mimic the behavior of DOM histories by
+            // causing a render after a cancelled POP.
+            setState();
+          }
         }
-      });
+      );
     }
 
     function goBack() {
@@ -1055,7 +1241,7 @@
 
     var history = {
       length: entries.length,
-      action: 'POP',
+      action: "POP",
       location: entries[index],
       index: index,
       entries: entries,
@@ -1067,7 +1253,7 @@
       goForward: goForward,
       canGo: canGo,
       block: block,
-      listen: listen
+      listen: listen,
     };
     return history;
   }
@@ -1080,6 +1266,5 @@
   exports.parsePath = parsePath;
   exports.createPath = createPath;
 
-  Object.defineProperty(exports, '__esModule', { value: true });
-
-})));
+  Object.defineProperty(exports, "__esModule", { value: true });
+});
